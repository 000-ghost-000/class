# types of models

[software.pdf](types%20of%20models%207a5abdca977d4cf6848e8a69b9d0490b/Export-6cbebdba-f798-497c-b39c-86b70fb26d89Private__Sharedclass_abf55772a1dd479d8f7b9eca1aab81d4software_engineering_and_modeling_06126a58f7494d8cb4d12c8a7c7cad10software.pdf)

---

---

### prototype model /
throw away prototype model:

![https://media.geeksforgeeks.org/wp-content/uploads/PrototypeModel.jpeg](https://media.geeksforgeeks.org/wp-content/uploads/PrototypeModel.jpeg)

## **Prototyping
Model in Software Development: In Detail**

**Concept:**

- Creating a simplified, working model of a software product early in
the development process to gather feedback and refine the design.
- Think of it as a rough draft or sketch before writing the final
novel.

**Benefits:**

- **Early user feedback:** Identify usability issues and
ensure the software aligns with user needs before significant
development effort.
- **Reduced risk of failure:** Catch critical flaws early
to avoid costly rework later.
- **Improved communication:** Facilitate discussions and
clarify expectations for developers, stakeholders, and investors.
- **Flexibility and adaptability:** Easily modify the
prototype based on feedback and changing needs.
- **Marketing and fundraising:** Showcase the product’s
potential to secure funding and generate interest.
- **Efficient resource allocation:** Focus resources on
viable features and avoid distractions.
- **Developer morale boost:** Seeing progress and
positive feedback motivates the development team.

**Types of Prototypes:**

- **Low-fidelity:** Rough outline or mockups focusing on
core functionalities and overall user flow.
- **High-fidelity:** More realistic simulations with
visual design elements and interactive features.
- **Horizontal:** Focuses on a specific functionality or
section of the software.
- **Vertical:** Simulates the complete user experience
from start to finish.

**Process:**

1. **Requirement gathering and analysis:** Define the
project goals and user needs.
2. **Prototype development:** Build a basic, working model
using appropriate tools and resources.
3. **User evaluation:** Gather feedback through testing,
surveys, or interviews.
4. **Prototype refinement:** Incorporate feedback and
iterate on the prototype until it meets user expectations.
5. **Product development:** Use the final prototype as a
blueprint for full-fledged development.

**Challenges:**

- **Premature feedback:** Initial prototypes may not be
representative of the final product, leading to misleading
feedback.
- **Additional development cost:** Creating prototypes
adds to the overall project budget.
- **Over-reliance on prototype:** Don’t let the prototype
dictate the final product; adapt it to evolving needs.

**Overall:**

The prototype model offers significant benefits for software
development, especially when used strategically and adapted to specific
project needs. It’s a crucial tool for iterative design, user-centered
development, and reducing the risk of creating unsuccessful
products.

## evolutionary model:

### Evolutionary
Model in Software Development: In Detail

**Concept:**

- The Evolutionary model is a software development approach where the
software is continuously refined, updated, and evolved.
- Instead of a fixed project design, the design is revisited and
revised based on feedback and learning from earlier stages.
- It’s a cyclic model where the process starts with the initial
product idea and continues with the development, feedback collection,
and further refinement.

**Benefits:**

- **Flexibility:** The model is adaptable to changes and
requirements that evolve over time.
- **Risk Management:** Allows early detection of flaws or
issues, reducing the risk of failure.
- **User Satisfaction:** Frequent releases mean that
software can be adapted based on user feedback, leading to increased
customer satisfaction.
- **Early Working Software:** Early stages of the system
are developed and made available to the users, which can lead to early
detection of any discrepancies or misunderstandings in the
requirements.

**Types of Evolutionary Models:**

- **Incremental Model:** Development is done in
increments with each increment adding new functionality.
- **Spiral Model:** Combines the idea of iterative
development with the systematic aspects of the traditional waterfall
model. It has four phases: identify, design, construct, and evaluate
that are iterated upon.
- **Concurrent Development Model:** Different system
aspects are developed simultaneously.

**Process:**

1. **Initial concept development:** Define the basic
project goals and user needs.
2. **Initial product development:** Develop an initial
software product version.
3. **User evaluation:** The software is evaluated in the
user environment.
4. **Software refinement:** Based on feedback, the
software is refined, and the process is repeated.

**Challenges:**

- **Project management:** As the process is iterative, it
can be more difficult to manage, especially for larger projects.
- **Undefined final product:** The final product is not
defined in advance, which might not be suitable for all types of
projects.

**Overall:**

The Evolutionary model is beneficial when requirements are unclear,
or technology is rapidly changing. It allows for flexibility and
adaptation, which can lead to a more successful final product that meets
user needs.

![https://media.geeksforgeeks.org/wp-content/uploads/20230703023132/evolutionary-process-model.jpg](https://media.geeksforgeeks.org/wp-content/uploads/20230703023132/evolutionary-process-model.jpg)

https://media.geeksforgeeks.org/wp-content/uploads/20230703023132/evolutionary-process-model.jpg

## incremental prototype:

### Incremental
Prototyping in Software Development: In Detail

**Concept:**

- Incremental prototyping involves building a software prototype in
increments or stages.
- Each increment or stage involves the development and refinement of a
specific feature or functionality of the software.
- Upon completion of each increment, the prototype is reviewed and
evaluated, and feedback is collected. This feedback is then used to
refine the next increment.
- This process continues until all the features or functionalities of
the software have been developed and refined.

**Benefits:**

- **Feedback-driven development:** Each increment is
evaluated and refined based on feedback, ensuring that the final product
meets user needs and expectations.
- **Risk management:** Allows for the early
identification and resolution of issues, reducing the risk of
failure.
- **Efficiency:** Because development is done in
increments, resources can be allocated more efficiently.
- **User satisfaction:** The incremental approach allows
users to be involved in the development process, which can lead to
increased user satisfaction.

**Process:**

1. **Requirement gathering and analysis:** Define the
project goals, user needs, and the features or functionalities to be
developed.
2. **Incremental development:** Develop and refine each
feature or functionality in increments.
3. **User evaluation:** Gather feedback through testing,
surveys, or interviews after each increment.
4. **Refinement:** Incorporate feedback and refine the
next increment.
5. **Product development:** Use the final prototype as a
blueprint for full-fledged development.

**Challenges:**

- **Project management:** Managing the development
process can be more challenging due to the iterative nature of
incremental prototyping.
- **Time-consuming:** Depending on the complexity of the
software, developing and refining each increment can be
time-consuming.

**Overall:**

Incremental prototyping is a beneficial approach to software
development that allows for feedback-driven development and efficient
resource allocation. It is especially useful when developing complex
software with multiple features or functionalities.

![https://static.javatpoint.com/tutorial/software-engineering/images/software-engineering-incremental-model.jpg](https://static.javatpoint.com/tutorial/software-engineering/images/software-engineering-incremental-model.jpg)

“build n → communication → planning → modelling → development → deployment”

### spiral model:

The spiral model is a risk-driven software development process model
that iteratively combines the features of waterfall and prototyping
models. It emphasizes early risk identification and mitigation while
building the software in incremental releases.

Here’s a breakdown of the key characteristics of the spiral
model:

![https://media.geeksforgeeks.org/wp-content/uploads/20230728095557/spiral-1-1024x945-660.webp](https://media.geeksforgeeks.org/wp-content/uploads/20230728095557/spiral-1-1024x945-660.webp)

https://media.geeksforgeeks.org/wp-content/uploads/20230728095557/spiral-1-1024x945-660.webp

**Key Features:**

- **Risk-driven:** Each cycle of the spiral focuses on
identifying and addressing the primary risks associated with the current
development stage.
- **Iterative:** The software is developed in a series of
incremental releases, allowing for early feedback and adaptation.
- **Prototyping:** Prototypes are used at each iteration
to validate functionality and design, reducing the risk of building the
wrong product.
- **Controlled:** Each spiral cycle follows a defined
plan with specific goals and deliverables.
- **Adaptive:** The process can be adjusted based on
feedback and changing requirements.

**Benefits:**

- **Reduced risk:** Early identification and mitigation
of risks can prevent costly mistakes later in development.
- **Improved quality:** Prototyping and iterations allow
for feedback-driven refinement, resulting in a higher-quality
product.
- **Flexibility:** The adaptable nature of the model
allows for changes in requirements and technology.
- **Early stakeholder involvement:** Stakeholders are
involved throughout the process, reducing the risk of misalignment.

**Challenges:**

- **Complexity:** The spiral model can be more complex to
manage than other models, requiring strong project management
skills.
- **Cost:** Prototyping and iteration can add to the
overall project cost.
- **Risk assessment:** Accurate risk identification and
prioritization are crucial for the model’s success.

**When to use:**

The spiral model is best suited for projects with:

- High risk and uncertainty
- Complex requirements
- Need for early user feedback
- Need for flexibility and adaptability

**Example applications:**

- Large-scale software development projects
- Mission-critical systems
- New product development
- Projects with evolving requirements

### v-model (verification,
validation):

The V-model, also known as the Verification and Validation model, is
a software development process model that resembles the letter V in its
structure. It emphasizes rigorous testing at each stage of development,
aiming to catch errors early and minimize rework.

![https://media.geeksforgeeks.org/wp-content/uploads/20231030123258/software-Testing-Tutorial-SDLC-V-model.webp](https://media.geeksforgeeks.org/wp-content/uploads/20231030123258/software-Testing-Tutorial-SDLC-V-model.webp)

https://media.geeksforgeeks.org/wp-content/uploads/20231030123258/software-Testing-Tutorial-SDLC-V-model.webp

**Key Characteristics:**

- **Verification (left side of V):** Focuses on ensuring
that the software is developed according to the requirements and
specifications. This involves tasks like requirement
analysis, design, coding, and unit testing.
- **Validation (right side of V):** Focuses on ensuring
that the software meets the needs of the user and solves the intended
problem. This involves integration testing, system testing, acceptance
testing, and user testing.
- **Testing at each stage:** Each development stage has a
corresponding testing stage on the other side of the V. This ensures
that any issues are identified and addressed as early as possible.
- **Sequential, but flexible:** The V-model follows a
sequential order, meaning each stage must be completed before moving to
the next. However, it can be flexible, allowing for iterations and
feedback loops based on testing results.

**Benefits:**

- **Early defect detection:** Catches errors early in the
development process, making them easier and cheaper to fix.
- **Improved quality:** Rigorous testing helps deliver a
higher quality product with fewer defects.
- **Clear documentation:** The model encourages detailed
documentation for each stage, which improves communication and
understanding.
- **Predictable timeline:** The sequential approach can
provide a clearer roadmap and timeline for development.

**Challenges:**

- **Less flexibility:** The sequential nature can make it
less adaptable to changing requirements compared to agile
methodologies.
- **Overemphasis on documentation:** Focusing too much on
documentation can slow down development progress.
- **Requirement uncertainty:** Can be challenging to
implement if requirements are not clearly defined early on.

**When to use:**

The V-model is well-suited for projects with:

- **Clearly defined and stable requirements**
- **High emphasis on quality and testing**
- **Formalized development processes**
- **Limited need for flexibility and agility**

**Examples:**

- Safety-critical systems (e.g., medical devices, aviation
systems)
- Embedded systems
- Large-scale enterprise applications

### Agile model:

what is agile?

it is a timeboxed iterated approach to software developers that build
software incrementally from the start of the project, instead of trying
to deliver it all at once it works by breaking the project into little
bits of user functionality called user stories, prioritizing them then
continuously delivering them in shorts cycles called iterations or
timebox

incremental model + rapid application development

![https://static.javatpoint.com/tutorial/software-engineering/images/software-engineering-agile-model.png](https://static.javatpoint.com/tutorial/software-engineering/images/software-engineering-agile-model.png)

https://static.javatpoint.com/tutorial/software-engineering/images/software-engineering-agile-model.png

Agile software development is a set of principles and practices that
emphasize:

- **Iterative and incremental development:** Breaking
down the software development process into small, time-boxed iterations
(usually 2-4 weeks) called sprints. Each sprint results in a working and
potentially shippable product increment.
- **Continuous feedback:** Stakeholders and users provide
feedback throughout the development process, allowing the team to adapt
and improve the product.
- **Collaboration and communication:** Agile teams are
self-organizing and cross-functional, meaning that team members have the
authority over their work and communicate effectively with each other
and with stakeholders.
- **Flexibility and adaptability:** Agile projects are
designed to be adaptable to changing requirements and priorities.

Here are some key benefits of using Agile for software
development:

- **Faster time to market:** Agile teams can deliver
working software more quickly than traditional waterfall teams.
- **Higher quality software:** The continuous feedback
loop helps to ensure that the software meets the needs of users and
stakeholders.
- **Increased customer satisfaction:** Agile teams are
more responsive to customer feedback, which leads to higher customer
satisfaction.
- **Improved team morale:** Agile teams are typically
more engaged and motivated than traditional teams.

Here are some of the most popular agile frameworks:

- **Scrum:** A simple and lightweight framework that
emphasizes short sprints, daily stand-up meetings, and product
backlogs.
- **Kanban:** A visual workflow management system that
focuses on continuous flow and delivery.
- **Lean:** A set of principles for optimizing software
development that emphasizes eliminating waste and improving value
delivery.

Whether or not agile is the right approach for your software
development project depends on a number of factors, such as the size and
complexity of the project, the team’s experience with agile, and the
organizational culture.

Here are some things to consider when deciding whether to use
Agile:

- **The size and complexity of the project:** Agile is
well-suited for small and medium-sized projects, but it can also be used
for larger projects if the team is experienced with Agile and the
project is well-defined.
- **The team’s experience with Agile:** If the team is
not experienced with Agile, it may be necessary to provide training and
support before starting an Agile project.
- **The organizational culture:** Agile requires a
culture of trust and collaboration, so it is important to make sure that
the organization is ready to adopt an agile approach.

project management framework:

- scrum
- extreme prog(XP)
- kanban
- Crystal
- ASD
- FDD

**The four core values of the Agile Manifesto are:**

1. **Individuals and interactions over processes and
tools**
2. **Working software over comprehensive
documentation**
3. **Customer collaboration over contract
negotiation**
4. **Responding to change by following a plan**