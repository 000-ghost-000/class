# requirement engineering

## requirement Enggineering :

requirement gathering:

- interviewing
- questionnaire(open/closed-ended)
- onsite observation
- study documents & software

model method:

- prototyping
- connective brainstorming
- joint app development
- rapid app development

the process of establishing the services that the customer requires
from a system and the constraints under which it operates and is
developed

### types of req. :

- user req.
- system req.
    - it is a detailed description of the system’s function services and
    operational constraints
- functional req.
- non-functional req.
    - speed (no. of transaction per sec/screen refresh time)
    - size
    - ease of use
    - reliability (mean time to failure)
    - availability
    - robustness
    - portability
- domain req.

### process of req engg :

The process of requirements engineering (RE) involves several key
steps that ensure software development goes smoothly and delivers a
product that meets stakeholder needs. Here’s a breakdown of the typical
RE process:

**1. Eliciting Requirements:**

it involves tech staff working with the customer to find out about
the app domain the services that the system should provide and the
systems …

- **Gather information:** Conduct
interviews, workshops, surveys, and observations to understand the
needs, expectations, and constraints of various stakeholders
(users, developers, business analysts, etc.).
- **Identify stakeholders:** Recognize all individuals or
groups who will be impacted by the software and have a vested interest
in its success.
- **Prioritize needs:** Analyze the gathered information
to determine the most critical functionalities and features based on
business goals, user priorities, and feasibility.

**2. Analyzing Requirements:**

- discovery
- classification and organization
- prioritizing and negation
- specification
- **Refine and clarify:** Ensure requirements are
unambiguous, complete, and consistent.
- **Identify conflicts and dependencies:** Check for
inconsistencies, redundancies, and logical conflicts between
requirements.
- **Analyze feasibility:** Assess whether the
requirements can be implemented within technical constraints and
budgetary limitations.
- **Perform risk assessment:** Identify potential risks
associated with specific requirements and develop mitigation
strategies.

**3. Documenting Requirements:**

- **Formalize requirements:** Use a standard format like
user stories, use cases, functional and non-functional
specifications, or other appropriate documentation methods.
- **Ensure traceability:** Maintain clear links between
requirements, design documents, and the final software product for
easier maintenance and verification.
- **Version control:** Track changes made to requirements
throughout the development process.

**4. Validating Requirements:**

- **Conduct reviews:** Hold formal inspections with
stakeholders to ensure requirements are understood and meet their
expectations.
- **Prototype and test:** Develop early versions of the
system or specific features to gather user feedback and validate
requirements.
- **Conduct usability testing:** Observe users
interacting with the system to identify any usability issues and refine
requirements accordingly.

**5. Managing Requirements:**

- **Communicate effectively:** Ensure all stakeholders
are kept informed about changes in requirements and understand their
rationale.
- **Implement change control:** Establish a process for
handling requests for changes to existing requirements, considering
impact and feasibility.
- **Maintain requirements document:** Update the
requirements document throughout the development process to reflect any
changes.

## decision table

- bank provide interest for male senior citizen 10% and for rest as
9%
- companies employee are paid bonuses if they work more than year and
achieve individual agreed target

## decision tree:

In software engineering, decision trees are often used to visually
represent and implement decision-making logic within programs. They
offer a flowchart-like structure that maps out conditions and their
corresponding actions, helping programmers break down complex decisions
into simpler steps.

- **Nodes:** Representing decision points or actions.
    - **Root Node:** The starting point of the tree, where
    the initial decision is made.
    - **Internal Nodes:** Represent intermediate decision
    points, with branches leading to other nodes.
    - **Leaf Nodes:** Represent final outcomes or
    actions.
- **Branches:** Connecting nodes, signifying possible
paths based on decision outcomes.
- **Conditions:** Evaluated at each decision
point, determining which branch to follow.

Q - if the travel cost per km is expensive the person uses a car if
standard price use train if cheap and if person male then bus if female
then check how many car she has if no case bus otherwise train

sol -