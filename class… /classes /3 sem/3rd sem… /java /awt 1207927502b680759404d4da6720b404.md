# awt

**Abstract Window Toolkit (AWT) in Java**

AWT (Abstract Window Toolkit) is a platform-dependent, graphical user interface (GUI) toolkit in Java that provides a set of APIs for creating and managing graphical components. It is part of the Java Foundation Classes (JFC) and allows developers to build window-based applications. AWT serves as a bridge between Java applications and native GUI components, making it a key element for creating cross-platform Java applications.

### Key Features of AWT:

1. **Platform-Dependent Rendering:** AWT components are rendered using the underlying operating system's native GUI components, which ensures a consistent look and feel across different platforms.
2. **Event-Driven Programming:** It follows an event-driven programming model where user interactions generate events (e.g., button clicks, mouse movements) that can be handled by event listeners.
3. **Basic Set of Components:** Provides a basic set of GUI components like buttons, text fields, labels, menus, and more. These are often referred to as heavyweight components because they rely on native peers.
4. **Layout Managers:** AWT uses layout managers to arrange components in a container. Different layout managers (e.g., BorderLayout, FlowLayout, GridLayout) provide various ways to position components.

### AWT Architecture

The architecture of AWT can be divided into three main parts:

1. **Components:** Basic building blocks of a GUI, such as buttons, labels, text fields, etc.
2. **Containers:** Special components that can hold other components (e.g., Frame, Panel).
3. **Event Handling:** Mechanism for responding to user interactions, which is central to event-driven programming in AWT.

### AWT Components

AWT provides various GUI components for building graphical applications:

1. **Component Class:** The root class for all AWT components. It provides basic properties like size, position, and visibility.
2. **Common AWT Components:**
    - **Label:** Displays a single line of read-only text.
    - **Button:** A push-button that can trigger an action when clicked.
    - **TextField:** Allows single-line text input from the user.
    - **TextArea:** Allows multi-line text input from the user.
    - **Checkbox:** Provides a selectable box that can be checked or unchecked.
    - **Choice:** Creates a dropdown menu for selecting one item from a list.
    - **List:** Displays a list of items, allowing single or multiple selections.
    - **Canvas:** A blank rectangular area where custom graphics can be drawn.
    - **Scrollbar:** Allows the user to scroll through content.
3. **Containers:**
    - **Frame:** Represents a top-level window with a title and border.
    - **Panel:** A simple container used to organize components inside another container.
    - **Window:** A top-level container that lacks borders and a title.
    - **Dialog:** A pop-up window that can be modal (blocking other windows) or non-modal.

### AWT Layout Managers

AWT layout managers control the size and position of components inside a container:

1. **FlowLayout:** Arranges components in a row, and wraps them to the next row when the current row is full.
2. **BorderLayout:** Divides the container into five regions: North, South, East, West, and Center. Each region can hold one component.
3. **GridLayout:** Arranges components in a grid of rows and columns, making each cell the same size.
4. **CardLayout:** Allows for switching between different panels, each acting as a card.
5. **GridBagLayout:** A flexible layout manager that allows components to span multiple rows and columns.

### AWT Event Handling

Events are generated by user actions (e.g., clicks, key presses) and are handled using event listeners. The key components of AWT event handling include:

1. **Event Sources:** Objects that generate events (e.g., Button, TextField).
2. **Event Objects:** Instances of classes derived from `java.awt.event.AWTEvent` (e.g., ActionEvent, KeyEvent, MouseEvent) that contain information about the event.
3. **Event Listeners:** Interfaces with methods that handle events. Common listeners include:
    - **ActionListener:** Handles button clicks or menu item selections.
    - **MouseListener:** Handles mouse actions (click, enter, exit).
    - **KeyListener:** Handles keyboard actions (key press, key release).
    - **WindowListener:** Handles window-related actions (open, close).
4. **Event Delegation Model:** AWT uses this model, where events generated by components are delegated to listeners that handle them.

### AWT Graphics

AWT provides a `Graphics` class for drawing shapes, text, and images. It allows for:

1. **Drawing Shapes:** Lines, rectangles, ovals, polygons, etc.
2. **Drawing Text:** Using various fonts and styles.
3. **Working with Images:** Loading and displaying images.
4. **Custom Painting:** The `paint()` method can be overridden to perform custom drawing.

### Limitations of AWT

1. **Platform Dependency:** Since it uses native GUI components, the appearance may differ across platforms.
2. **Limited Features:** AWT components are basic and may not provide advanced features available in more modern libraries.
3. **Heavyweight Components:** AWT components rely on native peers, which can cause issues when mixing with lightweight components from other libraries like Swing.

### Example Code

A simple AWT program creating a window with a button:

```java
import java.awt.*;
import java.awt.event.*;

public class SimpleAWTExample extends Frame {
    SimpleAWTExample() {
        // Create a button
        Button button = new Button("Click Me!");

        // Set button properties
        button.setBounds(50, 50, 80, 30);

        // Add button to frame
        add(button);

        // Set frame properties
        setSize(300, 300);
        setLayout(null);
        setVisible(true);

        // Add window closing functionality
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                dispose();
            }
        });
    }

    public static void main(String[] args) {
        new SimpleAWTExample();
    }
}

```

This code creates a simple window containing a button labeled "Click Me!" and handles window closing to exit the application properly.

### Layout manager

**Layout Managers in Java AWT**

A layout manager in Java AWT (Abstract Window Toolkit) is an object that implements the `java.awt.LayoutManager` interface. It controls the arrangement and size of components within a container, such as a `Frame` or `Panel`. Instead of manually positioning components using coordinates, layout managers allow developers to manage the layout of components in a flexible and platform-independent way.

### Key Features of Layout Managers:

1. **Automatic Positioning:** Layout managers automatically position components based on their rules, making the interface adapt to different window sizes.
2. **Resizing Behavior:** They handle resizing of components when the container's size changes.
3. **Platform Independence:** Since layout managers are part of Java's AWT, they work across different platforms consistently.

### Types of Layout Managers

Java AWT provides several built-in layout managers, each with unique characteristics and rules for arranging components. Below are the commonly used layout managers:

1. **FlowLayout**
2. **BorderLayout**
3. **GridLayout**
4. **CardLayout**
5. **GridBagLayout**
6. **BoxLayout (from Swing)**

Let's explore each of these layout managers in detail:

---

### 1. FlowLayout

- **Description:** FlowLayout arranges components in a row, just like words in a paragraph. When the row becomes full, it wraps the components to the next row.
- **Default Layout Manager:** For containers like `Panel`.
- **Alignment Options:** Can align components to the left, center, or right.
- **Spacing:** Allows horizontal and vertical gaps (in pixels) between components.

**Constructor:**

```java
FlowLayout() // Center alignment with default spacing
FlowLayout(int alignment) // LEFT, RIGHT, CENTER alignment
FlowLayout(int alignment, int hgap, int vgap) // Specifies alignment and spacing

```

**Example:**

```java
Panel panel = new Panel();
panel.setLayout(new FlowLayout(FlowLayout.LEFT, 10, 20)); // Left-aligned, with spacing

```

---

### 2. BorderLayout

- **Description:** BorderLayout divides the container into five regions: North, South, East, West, and Center. Each region can hold only one component.
- **Default Layout Manager:** For top-level containers like `Frame`.
- **Behavior:** The components added to the border regions stretch to fill the space in their respective regions.

**Regions:**

- `BorderLayout.NORTH` - Top
- `BorderLayout.SOUTH` - Bottom
- `BorderLayout.EAST` - Right
- `BorderLayout.WEST` - Left
- `BorderLayout.CENTER` - Middle

**Constructor:**

```java
BorderLayout() // Default gaps of 0 pixels
BorderLayout(int hgap, int vgap) // Specifies horizontal and vertical gaps

```

**Example:**

```java
Frame frame = new Frame();
frame.setLayout(new BorderLayout(5, 10)); // Setting gaps between components
frame.add(new Button("North"), BorderLayout.NORTH);
frame.add(new Button("Center"), BorderLayout.CENTER);
frame.add(new Button("South"), BorderLayout.SOUTH);

```

---

### 3. GridLayout

- **Description:** GridLayout arranges components in a grid of rows and columns, where all cells have the same size.
- **Resizing:** Components expand to fill the available space equally.
- **Constructor Variants:** Allows specifying the number of rows and columns, as well as gaps between cells.

**Constructor:**

```java
GridLayout() // Single row layout
GridLayout(int rows, int cols) // Number of rows and columns
GridLayout(int rows, int cols, int hgap, int vgap) // With specified gaps

```

**Behavior:**

- If either `rows` or `cols` is set to zero, the other parameter determines the layout. For example, if `rows` is set to 0, the number of columns will dictate the number of rows automatically.

**Example:**

```java
Panel panel = new Panel();
panel.setLayout(new GridLayout(3, 2, 5, 5)); // 3 rows, 2 columns, with gaps

```

---

### 4. CardLayout

- **Description:** CardLayout allows switching between different panels (like flipping cards), where each panel is treated as a "card."
- **Use Case:** Useful for implementing tabbed views or wizard-like interfaces.

**Methods:**

- `first(Container parent)` - Shows the first card.
- `last(Container parent)` - Shows the last card.
- `next(Container parent)` - Shows the next card.
- `previous(Container parent)` - Shows the previous card.
- `show(Container parent, String name)` - Shows the card with the specified name.

**Constructor:**

```java
CardLayout() // Default gaps
CardLayout(int hgap, int vgap) // Specifies horizontal and vertical gaps

```

**Example:**

```java
CardLayout cardLayout = new CardLayout();
Panel panel = new Panel(cardLayout);
panel.add(new Button("Card 1"), "card1");
panel.add(new Button("Card 2"), "card2");
cardLayout.show(panel, "card1");

```

---

### 5. GridBagLayout

- **Description:** The most flexible and complex layout manager, allowing components to span multiple rows and columns.
- **Use Case:** Ideal for creating complex user interfaces with irregular layouts.
- **GridBagConstraints:** Specifies constraints for each component, such as position, size, and how it should grow or shrink.

**Common GridBagConstraints Fields:**

- `gridx` and `gridy` - Position of the component.
- `gridwidth` and `gridheight` - Number of cells the component spans.
- `weightx` and `weighty` - Space allocation when the container is resized.
- `fill` - Determines how the component should fill its display area.
- `anchor` - Alignment within the grid cell.

**Example:**

```java
GridBagLayout gridBagLayout = new GridBagLayout();
Panel panel = new Panel(gridBagLayout);
GridBagConstraints gbc = new GridBagConstraints();
gbc.gridx = 0;
gbc.gridy = 0;
gbc.gridwidth = 2;
panel.add(new Button("Button"), gbc);

```

---

### 6. BoxLayout (Swing)

- **Description:** BoxLayout arranges components either in a horizontal row (`BoxLayout.X_AXIS`) or a vertical column (`BoxLayout.Y_AXIS`).
- **Usage:** Requires importing the `javax.swing` package since it is part of the Swing library.

**Example:**

```java
Panel panel = new Panel();
panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
panel.add(new Button("Button 1"));
panel.add(new Button("Button 2"));

```

---

### Choosing the Right Layout Manager

The choice of layout manager depends on the application's requirements:

- **Use `FlowLayout`** for simple, left-to-right arrangements.
- **Use `BorderLayout`** for dividing a window into regions.
- **Use `GridLayout`** for uniformly sized components in a grid.
- **Use `CardLayout`** for switching between different panels.
- **Use `GridBagLayout`** for complex, non-uniform layouts.
- **Use `BoxLayout` (Swing)** for simple linear layouts in one direction.

### Custom Layout Managers

In cases where none of the built-in layout managers meet the requirements, developers can create custom layout managers by implementing the `LayoutManager` interface.

[Types of Layout Manager in Java.pdf](awt%201207927502b680759404d4da6720b404/Types_of_Layout_Manager_in_Java.pdf)

```java
/*Q - WAP to print first 10 numbers using applet*/
import java.applet.Applet;
import java.awt.Graphics;

/*
<applet code="NumberApplet" width=300 height=200>
</applet>
*/

public class NumberApplet extends Applet {
    public void paint(Graphics g) {
        int y = 20; // Starting y-coordinate for the first number

        // Loop to print the first 10 numbers
        for (int i = 1; i <= 10; i++) {
            g.drawString("Number: " + i, 50, y);
            y += 20; // Move to the next line for the next number
        }
    }
}

```

```java
/*give one example of menu scroll bar and choice, wap to demonstrate life cycle method of applet, write a short not event handling in java*/
import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;

/*
<applet code="MenuScrollChoiceApplet" width=400 height=300>
</applet>
*/

public class MenuScrollChoiceApplet extends Applet implements AdjustmentListener, ItemListener {
    private Scrollbar scrollbar;
    private Choice choice;
    private Label label;

    public void init() {
        // Set layout
        setLayout(new FlowLayout());

        // Create a Scrollbar
        scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 0, 1, 0, 100);
        add(scrollbar);
        scrollbar.addAdjustmentListener(this);

        // Create a Choice
        choice = new Choice();
        choice.add("Option 1");
        choice.add("Option 2");
        choice.add("Option 3");
        add(choice);
        choice.addItemListener(this);

        // Create a Label to display results
        label = new Label("Adjust the scrollbar or select an option.");
        add(label);

        // Create a Menu
        MenuBar menuBar = new MenuBar();
        Menu menu = new Menu("Options");
        MenuItem item1 = new MenuItem("Item 1");
        MenuItem item2 = new MenuItem("Item 2");
        menu.add(item1);
        menu.add(item2);
        menuBar.add(menu);
        setMenuBar(menuBar);
    }

    public void adjustmentValueChanged(AdjustmentEvent e) {
        label.setText("Scrollbar value: " + scrollbar.getValue());
    }

    public void itemStateChanged(ItemEvent e) {
        label.setText("Selected: " + choice.getSelectedItem());
    }
}

```

```java
import java.applet.Applet;
import java.awt.Graphics;

/*
<applet code="LifeCycleApplet" width=300 height=200>
</applet>
*/

public class LifeCycleApplet extends Applet {
    public void init() {
        System.out.println("Applet Initialized");
    }

    public void start() {
        System.out.println("Applet Started");
    }

    public void paint(Graphics g) {
        System.out.println("Applet Painted");
        g.drawString("Hello, Applet!", 50, 50);
    }

    public void stop() {
        System.out.println("Applet Stopped");
    }

    public void destroy() {
        System.out.println("Applet Destroyed");
    }
}

```

### Short Note on Event Handling in Java

**Event Handling** in Java refers to managing events, which are actions or occurrences recognized by software (e.g., mouse clicks, key presses, or window actions). Java provides a robust mechanism for handling these events, based on the **Delegation Event Model**. In this model, an event is generated by a source, captured by a listener, and processed by a listener's method.

### Key Concepts:

1. **Event Source**: The component that generates an event (e.g., button, text field).
2. **Event Listener**: An interface that receives and processes events.
3. **Event Object**: Encapsulates information about the event (e.g., `ActionEvent`, `MouseEvent`).

### Commonly Used Event Listeners:

- **ActionListener**: For handling action events like button clicks.
- **MouseListener**: For mouse-related events.
- **KeyListener**: For keyboard events.
- **WindowListener**: For window events (closing, opening, etc.).

```java
Button button = new Button("Click Me");
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        System.out.println("Button Clicked!");
    }
});

```

This code creates a button and attaches an `ActionListener` to handle the button click event.